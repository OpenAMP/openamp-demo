#/bin/bash

ME=$(readlink -f $0)
SYSBASE=$(cd $(dirname $ME)/..; pwd)
SYS_ROOT=$SYSBASE/sysroot

# Where to get PMU rom image if we need it
PMU_ROM_URL=https://www.xilinx.com/bin/public/openDownload?filename=PMU_ROM.tar.gz

error() {
    echo "ERROR!: $@"
    exit 2
}

# make this available as a subcmd also
do_check-pmu-rom() {
    if [ ! -r $SYSBASE/firmware/pmu-rom.elf ]; then
        echo "Getting PMU ROM"
        PMU_TMP=$(mktemp -d)
        if ! wget -O $PMU_TMP/PMU_ROM.tar.gz $PMU_ROM_URL; then
            error "Can't get PMU ROM, can't continue"
        fi
        (cd $PMU_TMP; tar xvf PMU_ROM.tar.gz)
        cp $PMU_TMP/PMU_ROM/{pmu-rom.elf,PMU_ROM-LICENSE.txt} $SYSBASE/firmware/
        rm -rf $PMU_TMP/PMU_ROM/
        rmdir $PMU_TMP
    fi
}

any-cat() {
    #echo "ANY_CAT $@"
    if [ -z "$2" ]; then
        error "any-cat: destination file not set"
    fi

    case $1 in
    *.gz)
        zcat $1 >$2
        ;;
    *.bz2)
        bzcat $1 >$2
        ;;
    *.xz)
        xzcat $1 >$2
        ;;
    *)
        cat $1 >$2
        ;;
    esac
}

do_check-sd-img() {
    CLEAN_SD_IMG=$HOME/does-not-exist

    # we will only do this once, this is a preferece list
    for f in $IMAGES/clean-sd.img{.xz,.bz2,.gz,}; do
        CLEAN_SD_IMG="$f"
        break;
    done

    if [ ! -e $IMAGES/sd.img -a -e $CLEAN_SD_IMG ]; then
        echo "Creating sd.img from $(basename ${CLEAN_SD_IMG})"
        any-cat $CLEAN_SD_IMG $IMAGES/sd.img
    fi

    if [ ! -e $IMAGES/sd.img ]; then
        echo "Creating empty sd.img of size ${SD_DEFAULT_SIZE}MB"
        dd if=/dev/zero of=$IMAGES/sd.img bs=1M count=${SD_DEFAULT_SIZE} >/dev/null 2>&1
    fi
}

tmux-panel-title() {
    # the escape sequence seems harmless on non-tmux terms but check anyway
    if [ -n "$TMUX" ]; then
        printf '\033]2;%s\033\\' "$1"
    fi
}

# kill the current window if running in tmux
# if we started tmux and the user did not add windows,
# then this will kill the session also
tmux-kill() {
    if [ -n "$TMUX" ]; then
        tmux kill-window
        # should not really get here
    fi
}

ssh-rekey() {
    # Clear out any old known_key ssh value
    ssh-keygen -R [localhost]:1114 >/dev/null 2>&1 || true
    ssh-keygen -R localhost:1114 >/dev/null 2>&1 || true
}

do_start-qemu() {
    tmux-panel-title "Main UART, Quad A53, Ctrl-A x to quit"
    #echo "PMU_ARGS=$PMU_ARGS"
    #echo "APU_ARGS=$APU_ARGS"
    echo "Starting qemu ..."
    $SYS_ROOT/usr/bin/qemu-system-aarch64-multiarch \
        $APU_ARGS \
        -pmu-args "$PMU_ARGS"
    tmux-kill
}

do_sub-shell() {
    tmux-panel-title "$@"
    echo "This is a host shell"
    echo "After the QEMU board boots you can use ssh or scp from here"
    echo "Like  $ ssh qemu-zcu102"
    echo "or    $ scp mine.elf qemu-zcu102:/lib/firmware"
    echo
    echo "if you exit this shell, it will exit the emulator also"
    echo
    bash
    tmux-kill
}

do_my-socat() {
    PORT=$1; shift
    tmux-panel-title "$@"
    echo -n "waiting for port $PORT "
    while ! socat tcp:localhost:$PORT /dev/null >/dev/null 2>&1; do
        echo -n "."
        sleep 1
    done
    echo; echo "Connecting"
    socat tcp:localhost:$PORT /dev/tty
    echo "Conection closed, exiting"
    sleep 2
}

start-tmux() {
    export SYSROOT
    export APU_ARGS
    export PMU_ARGS

    if [ -z "$TMUX" ]; then
        tmux start-server
        tmux new-session -d -s QEMU -n qemu-zcu102 -d "$ME subcmd start-qemu"
        SESS="QEMU"
        tmux set -s -t $SESS mouse on
    else
        SESS=""
        tmux new-window -d -n qemu-zcu102 -d "$ME subcmd start-qemu"
        tmux set -s mouse on
    fi

    tmux set -w -t $SESS:qemu-zcu102 pane-border-status top

    # create a session with four panes
    tmux split-window -h -t $SESS:qemu-zcu102 "$ME subcmd sub-shell $USER@$HOSTNAME"
    tmux split-window -v -t $SESS:qemu-zcu102 "$ME subcmd my-socat 1115 '2nd UART, R5_0'"
    tmux split-window -v -t $SESS:qemu-zcu102 "$ME subcmd my-socat 1116 '3rd UART'"

    tmux select-pane -t $SESS:qemu-zcu102.0

    if [ -n "$SESS" ]; then
        tmux attach -t$SESS:qemu-zcu102
    else
        tmux select-window -t:qemu-zcu102
    fi
}

main() {
    SD_DEFAULT_SIZE=32

    if [ -n "$1" -a -d "$1" ]; then
        TESTBASE=$(readlink -f $1)
    else
        TESTBASE=$HOME/qemu-zcu102
        mkdir -p $TESTBASE
    fi

    IMAGES=$TESTBASE
    TFTPDIR=$TESTBASE/tftp

    do_check-pmu-rom
    do_check-sd-img

    FIRMWARE=$SYSBASE/firmware
    HW_DTBS=$SYSBASE/hw-dtbs/multiarch

    PMU_ARGS="-M microblaze-fdt \
        -display none \
        -hw-dtb $HW_DTBS/zynqmp-pmu.dtb \
        -kernel $FIRMWARE/pmu-rom.elf \
        -device loader,file=$FIRMWARE/pmu-firmware-zcu102-zynqmp.elf \
        -device loader,addr=0xfd1a0074,data=0x1011003,data-len=4 \
        -device loader,addr=0xfd1a007C,data=0x1010f03,data-len=4"

    APU_ARGS="-machine arm-generic-fdt \
        -hw-dtb $HW_DTBS/zcu102-arm.dtb \
        -m 4096 \
        -net nic -net nic -net nic -net nic,netdev=eth0 \
        -netdev user,id=eth0,hostfwd=tcp::1114-:22,tftp=$TFTPDIR \
        -drive if=sd,index=1,file=$IMAGES/sd.img,format=raw \
        -nographic \
        -serial mon:stdio \
        -serial tcp:localhost:1115,server,nowait \
        -serial tcp:localhost:1116,server,nowait \
        -global xlnx,zynqmp-boot.cpu-num=0 \
        -global xlnx,zynqmp-boot.use-pmufw=true \
        -device loader,file=$FIRMWARE/arm-trusted-firmware.elf,cpu-num=0 \
        -device loader,file=$FIRMWARE/u-boot.elf \
        -device loader,file=$FIRMWARE/system.dtb,addr=0x100000 \
        -boot mode=5"

    cd $TESTBASE

    if [ x"$QEMU_TMUX" = x"no" ]; then
        # user does not want us to do anything with TMUX, just start
        start-qemu
    else
        start-tmux
    fi
}

if [ x"$1" = x"subcmd" ]; then
    if [ -z "$2" ]; then error "subcmd needs a command"; fi
    CMD=$2; shift; shift; do_$CMD "$@"
else
    main "$@"
fi
